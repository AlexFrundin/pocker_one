import threading
#с использоланием глобальной переменной, должны разделять право на использование переменной
#для этого используешь объект  threading.Lock(), у него усть метод блокировки доступа к общим обЪектам
#l.acquire()
#l.locked() метод проверки состояния общего объекта(находтися в использовании или свободен)
#l.release() обновляешь состояние разделяемого ресурса и делаег=шь его оступным для другого потока
#в данном подходе (каки в любой многопоточности очень много подводных камней)
#если какой-то поток используется без Lock(), то он может вызвать исключение доступа((
a=0
l=threading.Lock()
def f():
    global a
    for i in range(10000):
        l.acquire()
        a+=1
        l.release()

#ts=[]
for i in range(100):
    t=threading.Thread(target=f)
    t.start()
    #ts.append(t)

#for t in ts:
    #t.join()

print(a)
